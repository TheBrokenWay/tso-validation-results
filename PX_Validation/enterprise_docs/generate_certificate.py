"""
Generate SYSTEM_VALIDATION_CERTIFICATE.md

Runs the full test suite and governance layers, captures results,
and produces a signed validation certificate.
"""
from __future__ import annotations

import hashlib
import json
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[2]


def _run_cmd(cmd: list[str], timeout: int = 300) -> tuple[int, str]:
    """Run a command and return (exit_code, output)."""
    try:
        result = subprocess.run(
            cmd, capture_output=True, text=True, timeout=timeout, cwd=str(REPO_ROOT)
        )
        return result.returncode, result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return 1, f"TIMEOUT after {timeout}s"
    except Exception as e:
        return 1, str(e)


def _count_tests(output: str) -> tuple[int, int]:
    """Parse test output for passed/total counts."""
    passed = total = 0
    for line in output.splitlines():
        if "passed" in line.lower() and "/" in line:
            parts = line.split("/")
            for p in parts:
                nums = "".join(c for c in p if c.isdigit())
                if nums:
                    if not passed:
                        passed = int(nums)
                    else:
                        total = int(nums)
        if "Ran " in line and " test" in line:
            nums = "".join(c for c in line.split("Ran ")[1].split(" ")[0] if c.isdigit())
            if nums:
                total = int(nums)
        if line.strip() == "OK":
            passed = total
    return passed, total


def generate(output_dir: Path) -> Path:
    """Generate the system validation certificate."""
    ts = datetime.now(timezone.utc)
    stamp = ts.strftime("%Y%m%d_%H%M%S")

    # Run validation suite
    rc_tests, out_tests = _run_cmd(
        [sys.executable, "PX_Validation/tests/run_all_tests.py"]
    )
    test_passed, test_total = _count_tests(out_tests)

    # Run chaos tests
    rc_chaos, out_chaos = _run_cmd(
        [sys.executable, "PX_Validation/tests/test_chaos_penetration.py"]
    )
    chaos_passed, chaos_total = _count_tests(out_chaos)

    # Run governance
    rc_gov, out_gov = _run_cmd([sys.executable, "run_e2e_layers.py"])
    gov_layers = out_gov.count("OK")

    # Run TSO
    rc_tso, out_tso = _run_cmd([sys.executable, "TSO_Validator/run_validation.py"])

    all_pass = rc_tests == 0 and rc_chaos == 0 and rc_gov == 0 and rc_tso == 0
    status = "VALIDATED" if all_pass else "FAILED"

    cert_hash = hashlib.sha256(
        f"{ts.isoformat()}{test_passed}{chaos_passed}{gov_layers}{status}".encode()
    ).hexdigest()[:16]

    content = f"""# PREDATOR X — SYSTEM VALIDATION CERTIFICATE

| Field | Value |
|-------|-------|
| **Certificate ID** | `PX-CERT-{stamp}-{cert_hash}` |
| **Generated** | {ts.isoformat()} |
| **Status** | **{status}** |
| **Platform Version** | v3.0.0 |
| **Python** | {sys.version.split()[0]} |

---

## 1. Test Suite Results

| Suite | Passed | Total | Exit Code |
|-------|--------|-------|-----------|
| Core Validation | {test_passed} | {test_total} | {rc_tests} |
| Chaos & Penetration | {chaos_passed} | {chaos_total} | {rc_chaos} |
| Governance E2E | {gov_layers} | 7 | {rc_gov} |
| TSO Validator | — | — | {rc_tso} |

## 2. Governance Layers

{_format_governance(out_gov)}

## 3. Constitutional Compliance

- **Toxicity Hard Limit**: 0.0210 (enforced, at-boundary FAILS)
- **Harmonic Overdrive**: 1.02 (fixed constant)
- **Fail-Closed Gates**: All gates default `authorized=False`
- **Anti-Sycophancy (Law 21)**: Cannot adjust values to bypass thresholds

## 4. Certificate Signature

```
SHA-256: {cert_hash}
Timestamp: {ts.isoformat()}
Status: {status}
```

---
*Generated by Predator X Enterprise Validation Suite v1.0.0*
"""

    out_path = output_dir / f"SYSTEM_VALIDATION_CERTIFICATE_{stamp}.md"
    out_path.write_text(content, encoding="utf-8")
    return out_path


def _format_governance(output: str) -> str:
    """Format governance layer results."""
    lines = []
    for line in output.splitlines():
        line = line.strip()
        if "Layer" in line or "OK" in line or "FAIL" in line:
            lines.append(f"- {line}")
    return "\n".join(lines) if lines else "- (see governance output for details)"
